add = "reg.line", # Add regression line
conf.int = TRUE, # Add confidence interval
add.params = list(color = "red",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("Beak length (culmen) (mm)")+
xlab("Mean PC1")
ggscatter(dat, x =  "PC1" , y ="Beak.Length_Nares",
add = "reg.line", # Add regression line
conf.int = TRUE, # Add confidence interval
add.params = list(color = "red",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("Beak length (nares) (mm)")+
xlab("Mean PC1")
ggscatter(dat, x = "PC1", y = "Beak.Width",
add = "reg.line", # Add regression line
conf.int = TRUE, # Add confidence interval
add.params = list(color = "green",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("Beak width (mm))")+
xlab("Mean PC1")
ggscatter(dat, x = "PC1", y = "Beak.Depth",
add = "reg.line", # Add regression line
conf.int = TRUE, # Add confidence interval
add.params = list(color = "orange",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("Beak delpth (mm))")+
xlab("Mean PC1")
library(ape)
library(phytools)
library(nlme)
library(visreg)
mytree<- read.nexus("output.nex")
#
mytree
class(mytree)
#Using consensus.edge function
trees<- consensus.edges(mytree, method = "least.squares", rooted= TRUE)
plot(trees, cex=0.7)
# Vector of species (tips) to be removed##because there are only 54 vocalising species
tips_to_remove <- c("Turdus_merula","Coracina_melanoptera", "Oriolus_chinensis", "Oriolus_oriolus", "Harpactes_fasciatus", "Pycnonotus_melanicterus", "Picus_squamatus", "Eumyias_thalassinus")
# Drop the specified tips from the tree
trees <- drop.tip(trees, tips_to_remove, trim.internal = TRUE,
subtree = FALSE, root.edge = 0,
rooted = is.rooted(trees),
collapse.singles = TRUE, interactive = FALSE)
dat$`Species Bird tree`
#Converting the species ID column into row names
mydata<- as.data.frame(dat)
rownames(mydata) <- mydata$`Species Bird tree`
#Reordering the rows to match the tree
mydata <- mydata[match(trees$tip.label,rownames(mydata)),]
trees$tip.label
mydata$`Species Bird tree`
#Phylogenetic signal for body mass (pagel's lambda)
phylosig(trees, as.matrix(mydata[,c("PC1")]))
#Phylogenetic signal for Beak variable (pagel's lambda)
phylosig(trees, as.matrix(mydata[,c("Beak.Length_Culmen")]))
phylosig(trees, as.matrix(mydata[,c("Beak.Length_Nares")]))
phylosig(trees, as.matrix(mydata[,c("Beak.Width")]))
phylosig(trees, as.matrix(mydata[,c("Beak.Depth")]))
#Independant contrasts
trees<- multi2di(trees) ##You can resolve multifurcations with branches of zero length using
#multi2di(), e.g.:
x1<- pic(dat$PC1, trees)
x1
y1<- pic(dat$Beak.Length_Culmen, trees)
y1
z1<- pic(dat$Beak.Length_Nares, trees)
z1
w1<- pic(dat$Beak.Width, trees)
p1<- pic(dat$Beak.Depth, trees)
phy_cor<- data.frame(x1, y1, z1, w1, p1)
names(phy_cor)<- c("PC1", "Beak length: culmen", "Beak length: nares", "Beak width", "Beak Depth")
head(phy_cor)
#Spearman's correlation
ggscatter(phy_cor, x = "PC1", y = "Beak length: culmen",
add = "reg.line", # Add regression line
conf.int = TRUE, # Add confidence interval
add.params = list(color = "red",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("PIC (Beak length: culmen (mm)")+
xlab("PIC (Mean PC1)")
#Spearman's correlation
ggscatter(phy_cor, x = "PC1", y = "Beak length: nares",
add = "reg.line", # Add regression line
conf.int = TRUE, # Add confidence interval
add.params = list(color = "green",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab(" PIC (Beak length: nares (mm)")+
xlab("PIC (Mean PC1)")
#Spearman's correlation
ggscatter(phy_cor, x = "PC1", y = "Beak width",
add = "reg.line", # Add regression line
conf.int = TRUE, # Add confidence interval
add.params = list(color = "orange",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("PIC (Beak width (mm)")+
xlab("PIC (Mean PC1)")
#Spearman's correlation
ggscatter(phy_cor, x = "PC1", y = "Beak Depth",
add = "reg.line", # Add regression line
conf.int = TRUE, # Add confidence interval
add.params = list(color = "grey",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("PIC(Beak depth (mm)")+
xlab("PIC (Mean PC1)")
library(tidyverse)
## Calculate PD for all flocks
library(picante)
mytree<- read.nexus("output.nex")
#
mytree # prints basic tree information
class(mytree)
#Using consensus.edge function
trees<- consensus.edges(mytree, method = "least.squares", rooted= T)
plot(trees, cex=0.7)
trees$tip.label
##Input matrix
dat<- read_csv("Matrix_visual_final.csv")
dat<- as.data.frame(dat)
# Extract the first column as character elements
row_names <- as.character(dat[, 1])
# Set the row names of the matrix to be the first column elements
rownames(dat) <- row_names
# Display the modified matrix with updated row names
print(dat)
# # #Reordering the rows to match the tree
dat <- dat[match(rooted_tree$tip.label,rownames(dat)),]
dat<- na.omit(dat) #Removing the outgroup because it is not present in the matrix
data<-t(dat)
#write.csv(data, "data_for_pd1.csv")
data<- read_csv("data_for_pd1.csv")
data<- as.data.frame(data)
data<- data[-1,]
# Extract the first column to be used as row names
rownames(data) <- data[, 1]
# Remove the first column
data <- data[, -1]
# Print the modified matrix
print(data)
# Faith's PD
PD<-pd(data,rooted_tree,include.root=F) #Faith's PD using community matrix and pruned tree
# Faith's PD
PD<-pd(data,trees,include.root=F) #Faith's PD using community matrix and pruned tree
PD #worked
###Alternate path to calculate the Faith's pd ses values
a<- ses.pd(data, rooted_tree,null.model = "independentswap", runs=999,
iterations=1000)
###Alternate path to calculate the Faith's pd ses values
a<- ses.pd(data, trees,null.model = "independentswap", runs=999,
iterations=1000)
# Faith's PD
PD<-pd(data,trees,include.root=T) #Faith's PD using community matrix and pruned tree
# Faith's PD
PD<-pd(data,trees,include.root=T) #Faith's PD using community matrix and pruned tree
PD #worked
###Alternate path to calculate the Faith's pd ses values
a<- ses.pd(data, trees,null.model = "independentswap", runs=999,
iterations=1000)
is.rooted(trees)
## Calculate PD for all flocks
library(picante)
mytree<- read.nexus("output1.nex")
#
mytree # prints basic tree information
class(mytree)
#Using consensus.edge function
trees<- consensus.edges(mytree, method = "least.squares", rooted= T)
plot(trees, cex=0.7)
trees$tip.label
outgroup<- "Spilornis_cheela"
# Root the tree using the outgroup
rooted_tree <- root(trees, outgroup = outgroup, resolve.root = TRUE)
# Plot the rooted tree
plot(rooted_tree, main = "Rooted Tree", cex=0.7)
# Faith's PD
PD<-pd(data,rooted_tree,include.root=T) #Faith's PD using community matrix and pruned tree
PD #worked
###Alternate path to calculate the Faith's pd ses values
a<- ses.pd(data, rooted_tree,null.model = "independentswap", runs=999,
iterations=1000)
#
ses<- a$pd.obs.z
###Alternate path to calculate the Faith's pd ses values
a<- ses.pd(data, rooted_tree,null.model = "independentswap", runs=999,
iterations=1000)
#
ses<- a$pd.obs.z
treebm<- read.nexus("output.nex")
treebm
treesbm<- consensus.edges(treebm, method = "least.squares", rooted= T)
plot(treesbm, cex=0.7)
bodymass<- read_csv("Body_variables_Birdtree_ID.csv")
bodymass<- as.data.frame(bodymass)
rownames(bodymass)<- bodymass$`Species Bird tree`
##Matching the rows to match the tree
treesbm$tip.label
dat<- bodymass[match(treesbm$tip.label, rownames(bodymass)),]
rownames(dat)
treesbm2<- multi2di(treesbm)
# Calculate Blomberg's K
k_result <- phylosig(treesbm, dat$`Body mass`, method = "K", test=TRUE)
print(k_result)
pc1<- read_csv("PC1_species.csv")
pc1<- left_join(pc1,bodymass, by= "Species 1")
pc1<- read_csv("PC1_species.csv")
pc1<- left_join(pc1,bodymass, by= "Species")
pc1<- pc1[,c(7,3)]
pc1<- as.data.frame(pc1)
rownames(pc1)<- pc1$`Species Bird tree`
tree2<- read.nexus("output.nex")
tree2
trees2<- consensus.edges(tree2, method = "least.squares", rooted= TRUE)
plot(trees2, cex=0.7)
# Vector of species (tips) to be removed##because there are only 54 vocalising species
tips_to_remove <- c("Turdus_merula","Coracina_melanoptera", "Oriolus_chinensis", "Oriolus_oriolus", "Harpactes_fasciatus", "Pycnonotus_melanicterus", "Picus_squamatus", "Eumyias_thalassinus")
# Drop the specified tips from the tree
treespc <- drop.tip(trees2, tips_to_remove, trim.internal = TRUE,
subtree = FALSE, root.edge = 0,
rooted = is.rooted(trees2),
collapse.singles = TRUE, interactive = FALSE)
dat<- pc1[match(treespc$tip.label, rownames(pc1)),]
rownames(dat)
treespc$tip.label
treespc1<- multi2di(treespc)
# Calculate Blomberg's K
k_result <- phylosig(treespc1, dat$PC1, method = "K", test=TRUE)
print(k_result)
c<- read_csv("correlation.csv")
ggscatter(c, x = "Body mass", y = "Acoustic",
add = "reg.line",                                 # Add regression line
conf.int = TRUE,                                  # Add confidence interval
add.params = list(color = "red",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("Vocal activity index")+
xlab("Body mass (g)")
mytree<-  read.nexus("output2.nex")
#
mytree               # prints basic tree information
class(mytree)
#Using consensus.edge function
trees<- consensus.edges(mytree, method = "least.squares", rooted= TRUE)
plot(trees)
trees$tip.label
mydata<- read_csv("correlation.csv")
#Converting the species ID column into row names
mydata<- as.data.frame(mydata)
rownames(mydata) <- mydata$`Species ID`
#Reordering the rows to match the tree
mydata <- mydata[match(trees$tip.label,rownames(mydata)),]
#
mydat2 <- mydata[, c(3,4)]
library(phytools)
dotTree(trees, as.matrix(mydat2)[,c("Acoustic")], method = "plotTree") # plot trait "Acoustic" at tree tips
# Close the plotting device
dev.off()
dotTree(trees, as.matrix(mydat2)[,c("Body mass")], method= "plotTree") # plot trait "Acoustic" at tree tips
dotTree(trees, as.matrix(mydat2)[,c("Acoustic")], method = "plotTree") # plot trait "Acoustic" at tree tips
dotTree(trees, as.matrix(mydat2)[,c("Body mass")], method= "plotTree") # plot trait "Acoustic" at tree tips
trees<- multi2di(trees) ##You can resolve multifurcations with branches of zero length using
x1<- pic(mydata$`Body mass`, trees)
x1
y1<- pic(mydata$Acoustic, trees)
y1
phy_cor<- data.frame(x1, y1)
names(phy_cor)<- c("Body mass", "Acoustic")
ggscatter(phy_cor, x = "Body mass", y = "Acoustic",
add = "reg.line",                                 # Add regression line
conf.int = TRUE,                                  # Add confidence interval
add.params = list(color = "red",
fill = "lightgray")
)+
stat_cor(method = "spearman")+
ylab("Vocal activity index")+
xlab("Body mass (g)")
setwd("D:/Papers/MSF_Acoustics/Analysis_Animal_behaviour/Repository/")
library(tidyverse)
mytree<- read.nexus("output.nex")
## Calculate PD for all flocks
library(picante)
mytree<- read.nexus("output.nex")
#
mytree # prints basic tree information
class(mytree)
#Using consensus.edge function
trees<- consensus.edges(mytree, method = "least.squares", rooted= T)
## Calculate PD for all flocks
library(picante)
mytree<- read.nexus("output.nex")
#
mytree # prints basic tree information
class(mytree)
#Using consensus.edge function
trees<- consensus.edges(mytree, method = "least.squares", rooted= T)
library(ape)
library(phytools)
library(nlme)
library(visreg)
#Using consensus.edge function
trees<- consensus.edges(mytree, method = "least.squares", rooted= T)
plot(trees, cex=0.7)
trees$tip.label
##Input matrix
dat<- read_csv("Matrix_visual_final.csv")
dat<- as.data.frame(dat)
# Extract the first column as character elements
row_names <- as.character(dat[, 1])
# Set the row names of the matrix to be the first column elements
rownames(dat) <- row_names
# Display the modified matrix with updated row names
print(dat)
# # #Reordering the rows to match the tree
dat <- dat[match(rooted_tree$tip.label,rownames(dat)),]
dat<- na.omit(dat) #Removing the outgroup because it is not present in the matrix
data<-t(dat)
#write.csv(data, "data_for_pd1.csv")
data<- read_csv("data_for_pd1.csv")
data<- as.data.frame(data)
data<- data[-1,]
# Extract the first column to be used as row names
rownames(data) <- data[, 1]
# Remove the first column
data <- data[, -1]
# Print the modified matrix
print(data)
# Faith's PD
PD<-pd(data,rooted_tree,include.root=T) #Faith's PD using community matrix and pruned tree
PD #worked
###Alternate path to calculate the Faith's pd ses values
a<- ses.pd(data, rooted_tree,null.model = "independentswap", runs=999,
iterations=1000)
#
ses<- a$pd.obs.z
ses
hist(ses)
hist(ses, breaks=50)
# Create a smoothed density plot with interesting colors
plot1 <- ggplot(data.frame(value = ses), aes(x = ses)) +
geom_density(fill = "skyblue", color = "darkblue", alpha = 0.7) +
xlab("SES values across flocks") +
ylab("Probabiliy density")+
theme_classic2()+
theme(
axis.title.x = element_text(size = 20),  # Increase x-axis title font size
axis.title.y = element_text(size = 20),
axis.text.x = element_text(size = 14),  # Increase x-axis labels font size
axis.text.y = element_text(size = 14)   # Increase y-axis labels font size# Increase y-axis title font size
)
plot1
# Create a smoothed density plot with interesting colors
plot1 <- ggplot(data.frame(value = ses), aes(x = ses)) +
geom_density(fill = "skyblue", color = "darkblue", alpha = 0.7) +
xlab("SES values across flocks") +
ylab("Probabiliy density")+
theme_classic2()+
theme(
axis.title.x = element_text(size = 20),  # Increase x-axis title font size
axis.title.y = element_text(size = 20),
axis.text.x = element_text(size = 14),  # Increase x-axis labels font size
axis.text.y = element_text(size = 14)   # Increase y-axis labels font size# Increase y-axis title font size
)
library(ggpubr)
# Create a smoothed density plot with interesting colors
plot1 <- ggplot(data.frame(value = ses), aes(x = ses)) +
geom_density(fill = "skyblue", color = "darkblue", alpha = 0.7) +
xlab("SES values across flocks") +
ylab("Probabiliy density")+
theme_classic2()+
theme(
axis.title.x = element_text(size = 20),  # Increase x-axis title font size
axis.title.y = element_text(size = 20),
axis.text.x = element_text(size = 14),  # Increase x-axis labels font size
axis.text.y = element_text(size = 14)   # Increase y-axis labels font size# Increase y-axis title font size
)
plot1
setwd("D:/Papers/MSF_Acoustics/Analysis_Animal_behaviour/Repository/")
library(tidyverse)
dat<- read_csv("Acoustic_pcf_final.csv")
n_distinct(dat$Species)
dat_pcf<- read_csv("Acoustic_pcf_final.csv")
dat.pca<- prcomp(dat_pcf[, c(7:14)], center = T, scale. = T)
dat<- read_csv("Acoustic_pcf_final.csv")
n_distinct(dat$Species)
dat_pcf<- read_csv("Acoustic_pcf_final.csv")
# Count the number of rows with missing data
missing_rows_count <- sum(!complete.cases(dat_pcf))
missing_rows_count
# Print the number of rows with missing data
cat("Number of rows with missing data: ", missing_rows_count, "\n")
cat
dat_pcf<- read_csv("Acoustic_pcf_final.csv")
# Identify which rows have missing values
rows_with_missing <- which(!complete.cases(dat_pcf))
# Print the row indices with missing data
cat("Rows with missing data: ", rows_with_missing, "\n")
# Alternatively, you can print the rows themselves
dat_pcf[rows_with_missing, ]
View(dat_pcf[rows_with_missing, ])
dat_pcf<- read_csv("Acoustic_pcf_final.csv")
dat_pcf
dat_pcf[,15]
dat_pcf[,17]
dat_pcf<- dat_pcf[, -c(17,18)]
dat_pcf
dat_pcf<- dat_pcf[, -c(17,18)]
# Identify which rows have missing values
rows_with_missing <- which(!complete.cases(dat_pcf))
# Print the row indices with missing data
cat("Rows with missing data: ", rows_with_missing, "\n")
# Alternatively, you can print the rows themselves
dat_pcf[rows_with_missing, ]
View(dat_pcf[rows_with_missing, ])
dat.pca<- prcomp(dat_pcf[, c(7:14)], center = T, scale. = T)
dat_pcf<- na.omit(dat_pcf) #############
dat.pca<- prcomp(dat_pcf[, c(7:14)], center = T, scale. = T)
summary(dat.pca)
dat.pca$rotation
get_eigenvalue(dat.pca)
library(factoextra)
get_eigenvalue(dat.pca)
data<- cbind(dat_pcf, dat.pca$x[,1:2])
##Extracting the mean Pc2 scores for each species
data1<- data %>%
group_by(Species) %>%
summarise(PC1= mean(PC1))
data1
View(data1)
dat<- read_csv("Acoustic_pcf_final.csv")
n_distinct(dat$Species)
dat_pcf<- read_csv("Acoustic_pcf_final.csv")
dat_pcf<- dat_pcf[, -c(17,18)]
# Identify which rows have missing values
rows_with_missing <- which(!complete.cases(dat_pcf))
# Print the row indices with missing data
cat("Rows with missing data: ", rows_with_missing, "\n")
# Alternatively, you can print the rows themselves
dat_pcf[rows_with_missing, ]
dat_pcf<- na.omit(dat_pcf) #############
dat.pca<- prcomp(dat_pcf[, c(7:14)], center = T, scale. = T)
summary(dat.pca)
dat.pca$rotation
library(factoextra)
get_eigenvalue(dat.pca)
data<- cbind(dat_pcf, dat.pca$x[,1:2])
##Extracting the mean Pc2 scores for each species
data1<- data %>%
group_by(Species) %>%
summarise(PC1= mean(PC1))
View(data1)
dat.pca<- prcomp(dat_pcf[, c(7:14)], center = T, scale. = T)
summary(dat.pca)
dat.pca$rotation
library(factoextra)
get_eigenvalue(dat.pca)
data<- cbind(dat_pcf, dat.pca$x[,1:2])
##Extracting the mean Pc2 scores for each species
data1<- data %>%
group_by(Species) %>%
summarise(PC1= mean(PC1))
##Extracting the mean Pc2 scores for each species
data2<- data %>%
group_by(Species) %>%
summarise(PC1= mean(PC1))
dat_pcf<- read_csv("Acoustic_pcf_final.csv")
dat_pcf<- dat_pcf[, -c(17,18)]
# Identify which rows have missing values
rows_with_missing <- which(!complete.cases(dat_pcf))
# Print the row indices with missing data
cat("Rows with missing data: ", rows_with_missing, "\n")
# Alternatively, you can print the rows themselves
dat_pcf[rows_with_missing, ]
dat_pcf<- na.omit(dat_pcf) #############
dat.pca<- prcomp(dat_pcf[, c(7:14)], center = T, scale. = T)
summary(dat.pca)
dat.pca$rotation
library(factoextra)
get_eigenvalue(dat.pca)
data<- cbind(dat_pcf, dat.pca$x[,1:2])
##Extracting the mean Pc2 scores for each species
data1<- data %>%
group_by(Species) %>%
summarise(PC1= mean(PC1))
View(data1)
dat.pca<- prcomp(dat_pcf[, c(7:14)], center = T, scale. = T)
summary(dat.pca)
dat.pca$rotation
library(factoextra)
get_eigenvalue(dat.pca)
data<- cbind(dat_pcf, dat.pca$x[,1:2])
##Extracting the mean Pc2 scores for each species
data2<- data %>%
group_by(Species) %>%
summarise(PC1= mean(PC1))
View(data2)
